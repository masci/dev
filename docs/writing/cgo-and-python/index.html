<!doctype html>
<html lang="en-us">

<head>
  <title>Cgo and Python // /dev/ by Massimiliano Pippi</title>
  <meta charset="utf-8" />
  <meta name="generator" content="Hugo 0.55.6" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta name="author" content="John Doe" />
  <meta name="description"
    content="" />
  <link rel="stylesheet" href="https://dev.pippi.im/css/main.min.f90f5edd436ec7b74ad05479a05705770306911f721193e7845948fb07fe1335.css" />

  
<script type="application/javascript">
var doNotTrack = false;
if (!doNotTrack) {
	(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
	(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
	m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
	})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
	ga('create', 'UA-43125807-1', 'auto');
	
	ga('send', 'pageview');
}
</script>

  <meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Cgo and Python"/>
<meta name="twitter:description" content="This blog post was hosted in the Datadog Engineering Blog, you can read it here.
If you look at the new Datadog Agent, you might notice most of the codebase is written in Go, although the checks we use to gather metrics are still written in Python. This is possible because the Datadog Agent, a regular Go binary, embeds a CPython interpreter that can be called whenever it needs to execute Python code."/>

  <meta property="og:title" content="Cgo and Python" />
<meta property="og:description" content="This blog post was hosted in the Datadog Engineering Blog, you can read it here.
If you look at the new Datadog Agent, you might notice most of the codebase is written in Go, although the checks we use to gather metrics are still written in Python. This is possible because the Datadog Agent, a regular Go binary, embeds a CPython interpreter that can be called whenever it needs to execute Python code." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://dev.pippi.im/writing/cgo-and-python/" />
<meta property="article:published_time" content="2018-04-16T00:00:00&#43;01:00"/>
<meta property="article:modified_time" content="2018-04-16T00:00:00&#43;01:00"/>


</head>

<body>
  <header class="app-header">
    <a href="https://dev.pippi.im/"><img class="app-header-avatar"
        src="/images/massi.png"
        alt="John Doe" /></a>
    <h1>/about/</h1>
    <p>
              Massi here. Software developer, engineering manager, I can ops.
        Open source advocate and contributor, documentation fanatic, speaker at conferences.
        I wrote a book once.
    </p>
    <div class="app-header-social">
      
      <a target="_blank" href="https://github.com/masci"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-github">
  <title>github</title>
  <path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37 0 0 0-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44 0 0 0 20 4.77 5.07 5.07 0 0 0 19.91 1S18.73.65 16 2.48a13.38 13.38 0 0 0-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07 0 0 0 5 4.77a5.44 5.44 0 0 0-1.5 3.78c0 5.42 3.3 6.61 6.44 7A3.37 3.37 0 0 0 9 18.13V22"></path>
</svg></a>
      
      <a target="_blank" href="http://www.linkedin.com/in/masci"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-linkedin">
  <title>linkedin</title>
  <path d="M16 8a6 6 0 0 1 6 6v7h-4v-7a2 2 0 0 0-2-2 2 2 0 0 0-2 2v7h-4v-7a6 6 0 0 1 6-6z"></path><rect x="2" y="9" width="4" height="12"></rect><circle cx="4" cy="4" r="2"></circle>
</svg></a>
      
    </div>
  </header>
  <main class="app-container">
    
  <article class="post">
    <header class="post-header">
      <h1 class ="post-title">Cgo and Python</h1>
      <div class="post-meta">
        <div>
          <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-calendar">
  <title>calendar</title>
  <rect x="3" y="4" width="18" height="18" rx="2" ry="2"></rect><line x1="16" y1="2" x2="16" y2="6"></line><line x1="8" y1="2" x2="8" y2="6"></line><line x1="3" y1="10" x2="21" y2="10"></line>
</svg>
          Apr 16, 2018
        </div>
        <div>
          <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-clock">
  <title>clock</title>
  <circle cx="12" cy="12" r="10"></circle><polyline points="12 6 12 12 16 14"></polyline>
</svg>
          12 min read
        </div><div>
          <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-tag">
  <title>tag</title>
  <path d="M20.59 13.41l-7.17 7.17a2 2 0 0 1-2.83 0L2 12V2h10l8.59 8.59a2 2 0 0 1 0 2.82z"></path><line x1="7" y1="7" x2="7" y2="7"></line>
</svg>
          <a class="tag" href="https://dev.pippi.im/tags/golang/">golang</a><a class="tag" href="https://dev.pippi.im/tags/python/">python</a><a class="tag" href="https://dev.pippi.im/tags/cgo/">cgo</a></div></div>
    </header>
    <div class="post-content">
      

<p><strong>This blog post was hosted in the Datadog Engineering Blog, you can
<a href="https://www.datadoghq.com/blog/engineering/cgo-and-python/">read it here</a>.</strong></p>

<p>If you look at the <a href="https://github.com/DataDog/datadog-agent/">new Datadog Agent</a>,
you might notice most of the codebase is written in Go, although the checks we
use to gather metrics are still written in Python. This is possible because the
Datadog Agent, a regular Go binary, <a href="https://docs.python.org/2/extending/embedding.html">embeds</a> a CPython interpreter that
can be called whenever it needs to execute Python code. This process can be made
transparent using an abstraction layer so that you can still write idiomatic Go
code even when there&rsquo;s Python running under the hood.</p>

<p>There are a number of reasons why you might want to embed Python in a Go
application:</p>

<ul>
<li>It is useful during a port; gradually moving portions of an existing Python project to the new language without losing any functionality during the process.</li>
<li>You can reuse existing Python software or libraries without re-implementing them in the new language.</li>
<li>You can dynamically extend your software by loading and executing regular Python scripts, even at runtime.</li>
</ul>

<p>The list could go on, but for the Datadog Agent the last point is crucial: we
want you to be able to execute custom checks or change existing ones without
forcing you to recompile the Agent, or in general, to compile anything.</p>

<p>Embedding CPython is quite easy and well documented. The interpreter itself is
written in C and a C API is provided to programmatically perform operations at
a very low level, like creating objects, importing modules, and calling functions.</p>

<p>In this article we&rsquo;ll show some code examples, and we&rsquo;ll focus on keeping the Go
code idiomatic while interacting with Python at the same time, but before we
proceed we need to address a small gap: the embedding API is C but our main
application is Go, how can this possibly work?</p>

<h2 id="introducing-cgo">Introducing cgo</h2>

<p>There are <a href="https://dave.cheney.net/2016/01/18/cgo-is-not-go">a number of good reasons</a>
why you might not want to introduce cgo in your stack, but embedding CPython is
one of those cases where you must. <a href="https://golang.org/cmd/cgo/">Cgo</a> is not a
language nor a compiler. It&rsquo;s a <a href="https://en.wikipedia.org/wiki/Foreign_function_interface">Foreign Function Interface</a> (FFI), a mechanism we
can use in Go to invoke functions and services written in a different language,
specifically C.</p>

<p>When we say &ldquo;cgo&rdquo; we&rsquo;re actually referring to a set of tools, libraries, functions,
and types that are used by the go toolchain under the hood so we can keep doing
<code>go build</code> to get our Go binaries. An absolutely minimal example of a program
using cgo looks like this:</p>

<pre><code class="language-golang">package main

// #include &lt;float.h&gt;
import &quot;C&quot;
import &quot;fmt&quot;

func main() {
    fmt.Println(&quot;Max float value of float is&quot;, C.FLT_MAX)
}
</code></pre>

<p>The comment block right above the <code>import &quot;C&quot;</code> instruction is called a &ldquo;preamble&rdquo;
and can contain actual C code, in this case an header inclusion. Once imported,
the &ldquo;C&rdquo; pseudo-package lets us &ldquo;jump&rdquo; to the foreign code, accessing the <code>FLT_MAX</code>
constant. You can build the example by invoking <code>go build</code>, the same as if it
was plain Go.</p>

<p>If you want to have a look at all the work cgo does under the hood,
run <code>go build -x</code>. You&rsquo;ll see the &ldquo;cgo&rdquo; tool will be invoked to generate some C
and Go modules, then the C and Go compilers will be invoked to build the object
modules and finally the linker will put everything together.</p>

<p>You can read more about cgo on the <a href="https://blog.golang.org/c-go-cgo">Go blog</a>.
The article contains more examples and few useful links to get further into
details.</p>

<p>Now that we have an idea of what cgo can do for us, let&rsquo;s see how we can run
some Python code using this mechanism.</p>

<h2 id="embedding-cpython-a-primer">Embedding CPython: a primer</h2>

<p>A Go program that, technically speaking, embeds CPython is not as complicated as
you might expect. In fact, at the bare minimum, all we have to do is initialize
the interpreter before running any Python code and finalize it when we&rsquo;re done.
Please note that we&rsquo;re going to use Python 2.x throughout all the examples but
everything we&rsquo;ll see can be applied to Python 3.x as well with very little
adaptation. Let&rsquo;s look at an example:</p>

<pre><code class="language-golang">package main

// #cgo pkg-config: python-2.7
// #include &lt;Python.h&gt;
import &quot;C&quot;
import &quot;fmt&quot;

func main() {
    C.Py_Initialize()
    fmt.Println(C.GoString(C.Py_GetVersion()))
    C.Py_Finalize()
}
</code></pre>

<p>The example above does exactly what the following Python code would do:</p>

<pre><code class="language-python">import sys
print(sys.version)
</code></pre>

<p>You can see we put a <code>#cgo</code> directive in the preamble; those directives are
passed to the toolchain to let you change the build workflow. In this case, we
tell cgo to invoke &ldquo;pkg-config&rdquo; to gather the flags needed to build and link
against a library called &ldquo;python-2.7&rdquo; and pass those flags to the C compiler.
If you have the CPython development libraries installed in your system along
with pkg-config, this would let you keep using a plain <code>go build</code> to compile
the example above.</p>

<p>Back to the code, we use <code>Py_Initialize()</code> and <code>Py_Finalize()</code> to set up and shut
down the interpreter and the <code>Py_GetVersion</code> C function to retrieve the string
containing the version information for the embedded interpreter.</p>

<p>If you&rsquo;re wondering, all the cgo bits we need to put together to invoke the C
Python API are boilerplate code. This is why the Datadog Agent relies on
<a href="https://github.com/sbinet/go-python">go-python</a> for all the embedding operations;
the library provides a Go friendly thin wrapper around the C API and hides the
cgo details. This is another basic embedding example, this time using go-python:</p>

<pre><code class="language-golang">package main

import (
    python &quot;github.com/sbinet/go-python&quot;
)

func main() {
    python.Initialize()
    python.PyRun_SimpleString(&quot;print 'hello, world!'&quot;)
    python.Finalize()
}
</code></pre>

<p>This looks closer to regular Go code, no more cgo exposed and we can use Go
strings back and forth while accessing the Python API. Embedding looks powerful
and developer friendly. Time to put the interpreter to good use: let&rsquo;s try to
load a Python module from disk.</p>

<p>We don&rsquo;t need anything complex on the Python side, the ubiquitous &ldquo;hello world&rdquo;
will serve the purpose:</p>

<pre><code class="language-python"># foo.py
def hello():
    &quot;&quot;&quot;
    Print hello world for fun and profit.
    &quot;&quot;&quot;
    print &quot;hello, world!&quot;
</code></pre>

<p>The Go code is slightly more complex but still readable:</p>

<pre><code class="language-golang">// main.go
package main

import &quot;github.com/sbinet/go-python&quot;

func main() {
    python.Initialize()
    defer python.Finalize()

    fooModule := python.PyImport_ImportModule(&quot;foo&quot;)
    if fooModule == nil {
        panic(&quot;Error importing module&quot;)
    }

    helloFunc := fooModule.GetAttrString(&quot;hello&quot;)
    if helloFunc == nil {
        panic(&quot;Error importing function&quot;)
    }

    // The Python function takes no params but when using the C api
    // we're required to send (empty) *args and **kwargs anyways.
    helloFunc.Call(python.PyTuple_New(0), python.PyDict_New())
}
</code></pre>

<p>Once built, we need to set the <code>PYTHONPATH</code> environment variable to the current
working dir so that the import statement will be able to find the <code>foo.py</code> module.
From a shell, the command would look like this:</p>

<pre><code class="language-bash">$ go build main.go &amp;&amp; PYTHONPATH=. ./main
hello, world!
</code></pre>

<h2 id="the-dreadful-global-interpreter-lock">The dreadful Global Interpreter Lock</h2>

<p>Having to bring in cgo in order to embed Python is a tradeoff: builds will be
slower, the Garbage Collector won&rsquo;t help us managing memory used by the foreign
system, and cross compilation will be non-trivial. Whether or not these are
concerns for a specific project can be debated, but there&rsquo;s something I deem not
negotiable: the Go concurrency model. If we couldn&rsquo;t run Python from a goroutine,
using Go altogether would make very little sense.</p>

<p>Before playing with concurrency, Python, and cgo, there&rsquo;s something we need to
know: it&rsquo;s the Global Interpreter Lock, also known as the GIL. The GIL is a
mechanism widely adopted in language interpreters (CPython is one of those)
preventing more than one thread from running at the same time. This means that
no Python program executed by CPython will be ever able to run in parallel within
the same process. Concurrency is still possible and in the end, the lock is a
good tradeoff between speed, security, and implementation simplicity. So why
should this pose a problem when it comes to embedding?</p>

<p>When a regular, non-embedded Python program starts, there&rsquo;s no GIL involved to
avoid useless overhead in locking operations; the GIL starts the first time some
Python code requests to spawn a thread. For each thread, the interpreter creates
a data structure to store information about the current state and locks the GIL.
When the thread has finished, the state is restored and the GIL unlocked, ready
to be used by other threads.</p>

<p>When we run Python from a Go program, none of the above happens automatically.
Without the GIL, multiple Python threads could be created by our Go program.
This could cause a race condition leading to fatal runtime errors, and most
likely a segmentation fault bringing down the whole Go application.</p>

<p>The solution to this problem is to explicitly invoke the GIL whenever we run
multithreaded code from Go; the code is not complex because the C API provides
all the tools we need. To better expose the problem, we need to do something
CPU bounded from Python. Let&rsquo;s add these functions to our foo.py module from
the previous example:</p>

<pre><code class="language-python"># foo.py
import sys

def print_odds(limit=10):
    &quot;&quot;&quot;
    Print odds numbers &lt; limit
    &quot;&quot;&quot;
    for i in range(limit):
        if i%2:
            sys.stderr.write(&quot;{}\n&quot;.format(i))

def print_even(limit=10):
    &quot;&quot;&quot;
    Print even numbers &lt; limit
    &quot;&quot;&quot;
    for i in range(limit):
        if i%2 == 0:
            sys.stderr.write(&quot;{}\n&quot;.format(i))
</code></pre>

<p>We&rsquo;ll try to print odd and even numbers concurrently from Go, using two
different goroutines (thus involving threads):</p>

<pre><code class="language-golang">package main

import (
    &quot;sync&quot;

    &quot;github.com/sbinet/go-python&quot;
)

func main() {
    // The following will also create the GIL explicitly
    // by calling PyEval_InitThreads(), without waiting
    // for the interpreter to do that
    python.Initialize()

    var wg sync.WaitGroup
    wg.Add(2)

    fooModule := python.PyImport_ImportModule(&quot;foo&quot;)
    odds := fooModule.GetAttrString(&quot;print_odds&quot;)
    even := fooModule.GetAttrString(&quot;print_even&quot;)

    // Initialize() has locked the the GIL but at this point we don't need it
    // anymore. We save the current state and release the lock
    // so that goroutines can acquire it
    state := python.PyEval_SaveThread()

    go func() {
        _gstate := python.PyGILState_Ensure()
        odds.Call(python.PyTuple_New(0), python.PyDict_New())
        python.PyGILState_Release(_gstate)

        wg.Done()
    }()

    go func() {
        _gstate := python.PyGILState_Ensure()
        even.Call(python.PyTuple_New(0), python.PyDict_New())
        python.PyGILState_Release(_gstate)

        wg.Done()
    }()

    wg.Wait()

    // At this point we know we won't need Python anymore in this
    // program, we can restore the state and lock the GIL to perform
    // the final operations before exiting.
    python.PyEval_RestoreThread(state)
    python.Finalize()
}
</code></pre>

<p>While reading the example you might note a pattern, the pattern that will become
our mantra to run embedded Python code:</p>

<ol>
<li>Save the state and lock the GIL.</li>
<li>Do Python.</li>
<li>Restore the state and unlock the GIL.</li>
</ol>

<p>The code should be straightforward but there&rsquo;s a subtle detail we want to point
out: notice that despite seconding the GIL mantra, in one case we operate the GIL
by calling <code>PyEval_SaveThread()</code> and <code>PyEval_RestoreThread()</code>, in another (look
inside the goroutines) we do the same with <code>PyGILState_Ensure()</code> and
<code>PyGILState_Release()</code>.</p>

<p>We said when multithreading is operated from Python, the interpreter takes care
of creating the data structure needed to store the current state, but when the
same happens from the C API, we&rsquo;re responsible for that.</p>

<p>When we initialize the interpreter with go-python, we&rsquo;re operating in a Python
context. So when <code>PyEval_InitThreads()</code> is called it initializes the data
structure and locks the GIL. We can use <code>PyEval_SaveThread()</code> and
<code>PyEval_RestoreThread()</code> to operate on already existing state.</p>

<p>Inside the goroutines, we&rsquo;re operating from a Go context and we need to
explicitly create the state and remove it when done, which is what
<code>PyGILState_Ensure()</code> and <code>PyGILState_Release()</code> do for us.</p>

<h2 id="unleash-the-gopher">Unleash the Gopher</h2>

<p>At this point we know how to deal with multithreading Go code executing Python
in an embedded interpreter but after the GIL, another challenge is right around
the corner: the Go scheduler.</p>

<p>When a goroutine starts, it&rsquo;s scheduled for execution on one of the <code>GOMAXPROCS</code>
threads availableâ€”<a href="https://morsmachine.dk/go-scheduler">see here</a> for more
details on the topic. If a goroutine happens to perform a syscall or call C
code, the current thread hands over the other goroutines waiting to run in the
thread queue to another thread so they can have better chances to run; the
current goroutine is paused, waiting for the syscall or the C function to
return. When this happens, the thread tries to resume the paused goroutine, but
if this is not possible, it asks the Go runtime to find another thread to
complete the goroutine and goes to sleep. The goroutine is finally scheduled to
another thread and it finishes.</p>

<p>With this in mind, let&rsquo;s see what can happen to a goroutine running some Python
code when a goroutine is moved to a new thread::</p>

<ol>
<li>Our goroutine starts, performs a C call, and pauses. The GIL is locked.</li>
<li>When the C call returns, the current thread tries to resume the goroutine, but it fails.</li>
<li>The current thread tells the Go runtime to find another thread to resume our goroutine.</li>
<li>The Go scheduler finds an available thread and the goroutine is resumed.</li>
<li>The goroutine is almost done and tries to unlock the GIL before returning.</li>
<li>The thread ID stored in the current state is from the original thread and is different from the ID of the current thread.</li>
<li>Panic!</li>
</ol>

<p>Luckily for us, we can force the Go runtime to always keep our goroutine running
on the same thread by calling the LockOSThread function from the runtime package
from within a goroutine:</p>

<pre><code class="language-golang">go func() {
    runtime.LockOSThread()

    _gstate := python.PyGILState_Ensure()
    odds.Call(python.PyTuple_New(0), python.PyDict_New())
    python.PyGILState_Release(_gstate)
    wg.Done()
}()
</code></pre>

<p>This will interfere with the scheduler and might introduce some overhead, but
it&rsquo;s a price that we&rsquo;re willing to pay to avoid random panics.</p>

<h2 id="conclusions">Conclusions</h2>

<p>In order to embed Python, the Datadog Agent has to accept a few tradeoffs:</p>

<ul>
<li>The overhead introduced by cgo.</li>
<li>The task of manually handling the GIL.</li>
<li>The limitation of binding goroutines to the same thread during execution.</li>
</ul>

<p>We&rsquo;re happy to accept each of these for the convenience of running Python checks
in Go. But by being conscious of the tradeoffs, we&rsquo;re able to minimize their
effect. Regarding other limitations introduced to support Python, we have few
countermeasures to contain potential issues:</p>

<ul>
<li>The build is automated and configurable so that devs have still something very similar to <code>go build</code>.</li>
<li>A lightweight version of the agent can be built stripping out Python support entirely simply using Go build tags.</li>
<li>Such a version only relies on core checks hardcoded in the agent itself (system and network checks mostly) but is cgo free and can be cross compiled.</li>
</ul>

<p>We&rsquo;ll re-evaluate our options in the future and decide whether keeping around
cgo is still worth it; we could even reconsider whether Python as a whole is
still worth it, waiting for the <a href="https://golang.org/pkg/plugin/">Go plugin package</a>
to be mature enough to support our use case. But for now the embedded Python is
working well and transitioning from the old Agent to the new one couldn&rsquo;t be easier.</p>

    </div>
    <div class="post-footer">
      
    </div>
  </article>

  </main>
</body>

</html>
