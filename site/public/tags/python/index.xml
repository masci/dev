<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>python on /dev/</title>
    <link>https://dev.pippi.im/tags/python/</link>
    <description>Recent content in python on /dev/</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Mon, 16 Apr 2018 00:00:00 +0100</lastBuildDate>
    
	<atom:link href="https://dev.pippi.im/tags/python/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Cgo and Python</title>
      <link>https://dev.pippi.im/writing/cgo-and-python/</link>
      <pubDate>Mon, 16 Apr 2018 00:00:00 +0100</pubDate>
      
      <guid>https://dev.pippi.im/writing/cgo-and-python/</guid>
      <description>This blog post was hosted in the Datadog Engineering Blog, you can read it here.
If you look at the new Datadog Agent, you might notice most of the codebase is written in Go, although the checks we use to gather metrics are still written in Python. This is possible because the Datadog Agent, a regular Go binary, embeds a CPython interpreter that can be called whenever it needs to execute Python code.</description>
    </item>
    
    <item>
      <title>Protobuf parsing in Python</title>
      <link>https://dev.pippi.im/writing/protobuf-python/</link>
      <pubDate>Thu, 08 Jun 2017 00:00:00 +0100</pubDate>
      
      <guid>https://dev.pippi.im/writing/protobuf-python/</guid>
      <description>This blog post was hosted in the Datadog Engineering Blog, you can read it here.
Recently we extended the Datadog Agent to support extracting additional metrics from Kubernetes using the kube-state-metrics service. Metrics are exported through an HTTP API that supports content negotiation so that one can choose between having the response body in plain text format or as a binary stream encoded using Protocol buffers.
Binary formats are generally assumed to be faster and more efficient, but being Datadog we wanted to see the data and quantify the improvement.</description>
    </item>
    
    <item>
      <title>If code is poetry, then documentation is prose</title>
      <link>https://dev.pippi.im/writing/if-code-is-poetry-then-documentation-is-prose/</link>
      <pubDate>Sat, 24 May 2014 00:00:00 +0000</pubDate>
      
      <guid>https://dev.pippi.im/writing/if-code-is-poetry-then-documentation-is-prose/</guid>
      <description>What is poetry? Before starting, let’s agree on some terminology. Obviously poetry is a literary form, a way to write down things I would say, but how do you recognize it, how can you say that is poetry and this is not? Well, according to my literary heritage (I’m italian) something is poetry when it has verse, rhyme and stanza; let’s see what they are and how we can recognize them.</description>
    </item>
    
    <item>
      <title>Uploading files to Google Cloud Storage with Django</title>
      <link>https://dev.pippi.im/writing/django-upload-on-google-cloud-storage/</link>
      <pubDate>Fri, 02 May 2014 00:00:00 +0000</pubDate>
      
      <guid>https://dev.pippi.im/writing/django-upload-on-google-cloud-storage/</guid>
      <description>Intro On of the features of Django Appengine Toolkit is simplifying the work needed to configure Google Cloud Storage as a static files storage for Django applications running on Google App Engine. Infact all you have to do is writing something like this in your settings.py module:
APPENGINE_TOOLKIT = { &amp;#39;APP_YAML&amp;#39;: os.path.join(BASE_DIR, &amp;#39;app.yaml&amp;#39;), &amp;#39;BUCKET_NAME&amp;#39;: &amp;#39;media-uploads&amp;#39;, } DEFAULT_FILE_STORAGE = &amp;#39;appengine_toolkit.storage.GoogleCloudStorage&amp;#39; STATICFILE_STORAGE = &amp;#39;appengine_toolkit.storage.GoogleCloudStorage&amp;#39; A complete example This repo contains a minimalistic Django project implementing a file storage application that lets users upload, listing, retrieve and delete files.</description>
    </item>
    
    <item>
      <title>Create a blog in minutes on App Engine with Django and Cloud Sql</title>
      <link>https://dev.pippi.im/writing/create-a-blog-in-minutes-on-app-engine-with-django/</link>
      <pubDate>Mon, 10 Feb 2014 00:00:00 +0000</pubDate>
      
      <guid>https://dev.pippi.im/writing/create-a-blog-in-minutes-on-app-engine-with-django/</guid>
      <description>Intro Django was actively supported at an early stage of the Python runtime in App Engine SDK through the notable django-nonrel framework, a fork of the original project that adds support for NoSql databases. But starting from the App Engine SDK 1.6.2, released more than two years ago, you can instead deploy Django&amp;rsquo;s official releases and take advantages from the whole stack using Google Cloud Sql.
Case study We&amp;rsquo;re going to setup a minimal project using Zinnia, a blog engine built on top of Django and a fairly complex web application that leverages several components of the framework, a good benchmark for showing how easy can be deploying on App Engine.</description>
    </item>
    
    <item>
      <title>Build GitHub like notifications with Django messages and AngularJS</title>
      <link>https://dev.pippi.im/writing/build-github-like-notifications-with-django-messages-and-angular-js/</link>
      <pubDate>Tue, 22 Oct 2013 00:00:00 +0000</pubDate>
      
      <guid>https://dev.pippi.im/writing/build-github-like-notifications-with-django-messages-and-angular-js/</guid>
      <description>Foreword GitHub has a very nice notification system, very similar to a plain old email inbox. You receive a notification which remains unread until you actually read it; then it&amp;rsquo;s archived and removed from your inbox, which it happens could remain empty:
For those who don&amp;rsquo;t know, Django ships a library for displaying &amp;ldquo;one-time&amp;rdquo; messages to the users, it&amp;rsquo;s called Message Framework and you can find it in the contrib package.</description>
    </item>
    
  </channel>
</rss>